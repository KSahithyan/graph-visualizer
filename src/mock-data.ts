import { GraphItem } from './data-types'
import { TIMESHIFT } from './values'

/**
 * returns the starting month of a quarter
 */
const getQuarterStartMonth = (n: number): string => (3 * n - 2).toString().padStart(2, '0')

/**
 * 
 */
const fix = (data: GraphItem[]): GraphItem[] => {
    let arr = [...data]

    data.forEach(item => {
        item.values.forEach(valueItem => {
            let quarter = +valueItem.timeDescription.match(/\sQ(\d)/)[1]
            valueItem.timeDescription = valueItem.timeDescription.replace(/\sQ\d/, `/${getQuarterStartMonth(quarter)}/01`)
            valueItem.time = new Date(valueItem.timeDescription).getTime()
        })
        item.width = item.width || 0
    })

    console.log(arr)
    return arr
}

/**
 * Computes and fills the mid-values of the data
 */
const fill = (_graphData: GraphItem[]): GraphItem[] => {
    let arr: GraphItem[] = []

    for (let j = 0; j < _graphData.length; j++) {
        let graphItem = _graphData[j];
        let newGraphItem: GraphItem = {
            itemName: graphItem.itemName,
            values: []
        }

        for (let i = 0; i < graphItem.values.length; i += 2) {
            let valueItem1 = graphItem.values[i];
            let valueItem2 = graphItem.values[i + 1];
            let hopsCount;

            // PROBLEM
            // When graphItem.values.length is odd, valueItem2 becomes undefined.
            // Find a sollution

            try {   
                hopsCount = (valueItem2.time - valueItem1.time) / TIMESHIFT
            } catch (e) {
                console.log(e, valueItem1, valueItem2)
            }
            let incrementalValue = (valueItem2.value - valueItem1.value) / hopsCount
            // add first
            newGraphItem.values.push(valueItem1)
            // add mid-hops
            for (let k = 1; k < hopsCount; k++) {
                newGraphItem.values.push({
                    time: Math.floor(valueItem1.time + (TIMESHIFT * k)),
                    value: Math.floor(valueItem1.value + (incrementalValue * k)),
                    timeDescription: "",
                })
            }
            // add second
            newGraphItem.values.push(valueItem2)
        }

        arr.push(newGraphItem)
    }
    console.log(arr)
    return arr
}

// `time` will be generated by fix function from the timeDescription
export const graphData: GraphItem[] = fill(fix([
    {
        itemName: "Facebook",
        values: [
            { time: 0, value: 100000000, timeDescription: "2008 Q3" },
            { time: 0, value: 197000000, timeDescription: "2009 Q1" },
            { time: 0, value: 242000000, timeDescription: "2009 Q2" },
            { time: 0, value: 305000000, timeDescription: "2009 Q3" },
            { time: 0, value: 360000000, timeDescription: "2009 Q4" },
            { time: 0, value: 431000000, timeDescription: "2010 Q1" },
            { time: 0, value: 482000000, timeDescription: "2010 Q2" },
            { time: 0, value: 550000000, timeDescription: "2010 Q3" },
            { time: 0, value: 608000000, timeDescription: "2010 Q4" },
            { time: 0, value: 680000000, timeDescription: "2011 Q1" },
            { time: 0, value: 739000000, timeDescription: "2011 Q2" },
            { time: 0, value: 800000000, timeDescription: "2011 Q3" },
            { time: 0, value: 845000000, timeDescription: "2011 Q4" },
            { time: 0, value: 901000000, timeDescription: "2012 Q1" },
            { time: 0, value: 955000000, timeDescription: "2012 Q2" },
            { time: 0, value: 1007000000, timeDescription: "2012 Q3" },
            { time: 0, value: 1056000000, timeDescription: "2012 Q4" },
            { time: 0, value: 1110000000, timeDescription: "2013 Q1" },
            { time: 0, value: 1155000000, timeDescription: "2013 Q2" },
            { time: 0, value: 1189000000, timeDescription: "2013 Q3" },
            { time: 0, value: 1228000000, timeDescription: "2013 Q4" },
            { time: 0, value: 1276000000, timeDescription: "2014 Q1" },
            { time: 0, value: 1317000000, timeDescription: "2014 Q2" },
            { time: 0, value: 1350000000, timeDescription: "2014 Q3" },
            { time: 0, value: 1393000000, timeDescription: "2014 Q4" },
            { time: 0, value: 1441000000, timeDescription: "2015 Q1" },
            { time: 0, value: 1490000000, timeDescription: "2015 Q2" },
            { time: 0, value: 1545000000, timeDescription: "2015 Q3" },
            { time: 0, value: 1591000000, timeDescription: "2015 Q4" },
            { time: 0, value: 1654000000, timeDescription: "2016 Q1" },
            { time: 0, value: 1712000000, timeDescription: "2016 Q2" },
            { time: 0, value: 1788000000, timeDescription: "2016 Q3" },
            { time: 0, value: 1860000000, timeDescription: "2016 Q4" },
            { time: 0, value: 1936000000, timeDescription: "2017 Q1" },
            { time: 0, value: 2006000000, timeDescription: "2017 Q2" },
            { time: 0, value: 2072000000, timeDescription: "2017 Q3" },
            { time: 0, value: 2129000000, timeDescription: "2017 Q4" },
            { time: 0, value: 2196000000, timeDescription: "2018 Q1" },
            { time: 0, value: 2234000000, timeDescription: "2018 Q2" },
            { time: 0, value: 2271000000, timeDescription: "2018 Q3" },
            { time: 0, value: 2320000000, timeDescription: "2018 Q4" },
            { time: 0, value: 2375000000, timeDescription: "2019 Q1" },
            { time: 0, value: 2414000000, timeDescription: "2019 Q2" },
            { time: 0, value: 2449000000, timeDescription: "2019 Q3" },
            { time: 0, value: 2498000000, timeDescription: "2019 Q4" },
            { time: 0, value: 2603000000, timeDescription: "2020 Q1" },
        ]
    }
]))